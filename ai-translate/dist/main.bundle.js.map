{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://excel-to-structured-data/webpack/runtime/chunk loaded","webpack://excel-to-structured-data/./src/components/progress.js","webpack://excel-to-structured-data/./src/components/Logger.js","webpack://excel-to-structured-data/./src/components/TableRenderer.js","webpack://excel-to-structured-data/./src/services/embedding.js","webpack://excel-to-structured-data/./src/services/embedding-instance.js","webpack://excel-to-structured-data/./src/utils/LanguageUtils.js","webpack://excel-to-structured-data/./src/services/translator.js","webpack://excel-to-structured-data/./src/services/TranslationManager.js","webpack://excel-to-structured-data/./src/ExcelTranslator.js","webpack://excel-to-structured-data/./src/utils/excel.js","webpack://excel-to-structured-data/./src/index.js","webpack://excel-to-structured-data/webpack/bootstrap","webpack://excel-to-structured-data/webpack/runtime/compat get default export","webpack://excel-to-structured-data/webpack/runtime/define property getters","webpack://excel-to-structured-data/webpack/runtime/global","webpack://excel-to-structured-data/webpack/runtime/hasOwnProperty shorthand","webpack://excel-to-structured-data/webpack/runtime/node module decorator","webpack://excel-to-structured-data/webpack/runtime/runtimeId","webpack://excel-to-structured-data/webpack/runtime/jsonp chunk loading","webpack://excel-to-structured-data/webpack/runtime/nonce","webpack://excel-to-structured-data/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","/**\n * 进度条组件\n */\nexport class ProgressBar {\n    /**\n     * 创建进度条组件\n     */\n    constructor() {\n        this.progressContainer = document.querySelector('.progress-container');\n        this.progressFill = document.querySelector('.progress-fill');\n        this.progressText = document.querySelector('.progress-text');\n        this.progressDetails = document.querySelector('.progress-details');\n        \n        // 创建批次计数器元素\n        this.progressBatchCounter = document.createElement('div');\n        this.progressBatchCounter.className = 'progress-batch-counter';\n        this.progressBatchCounter.style.textAlign = 'center';\n        this.progressBatchCounter.style.marginTop = '5px';\n        this.progressBatchCounter.style.fontSize = '14px';\n        this.progressBatchCounter.style.color = '#666';\n        \n        // 将批次计数器添加到进度条容器后面\n        this.progressContainer.parentNode?.insertBefore(\n            this.progressBatchCounter, \n            this.progressContainer.nextSibling\n        );\n    }\n\n    /**\n     * 更新进度\n     * @param {Object} data - 进度数据\n     * @param {number} data.current - 当前进度\n     * @param {number} data.total - 总进度\n     * @param {string} [data.text] - 进度文本\n     */\n    updateProgress(data) {\n        const percentage = (data.current / data.total) * 100;\n        this.progressFill.style.width = `${percentage}%`;\n        this.progressText.textContent = `${Math.round(percentage)}%`;\n        \n        if (data.text) {\n            this.progressDetails.textContent = data.text;\n        }\n    }\n    \n    /**\n     * 更新批次进度\n     * @param {Object} progress - 批次进度数据\n     * @param {number} progress.completedBatches - 已完成批次数\n     * @param {number} progress.totalBatches - 总批次数\n     * @param {number} progress.currentBatchId - 当前批次ID\n     * @param {number} progress.completedTasksInCurrentBatch - 当前批次已完成任务数\n     * @param {number} progress.totalTasksInCurrentBatch - 当前批次总任务数\n     */\n    updateBatchProgress(progress) {\n        // 更新总体进度\n        const overallPercentage = (progress.completedBatches / progress.totalBatches) * 100;\n        this.progressFill.style.width = `${overallPercentage}%`;\n        this.progressText.textContent = `${Math.round(overallPercentage)}%`;\n        \n        // 更新批次计数器\n        this.progressBatchCounter.textContent = `批次进度: ${progress.completedBatches}/${progress.totalBatches}`;\n        \n        // 更新详细信息\n        if (progress.currentBatchId > 0) {\n            const batchProgress = (progress.completedTasksInCurrentBatch / progress.totalTasksInCurrentBatch) * 100;\n            this.progressDetails.textContent = `当前批次 ${progress.currentBatchId}/${progress.totalBatches}: 完成 ${Math.round(batchProgress)}%`;\n        }\n    }\n\n    /**\n     * 重置进度条\n     */\n    reset() {\n        this.progressFill.style.width = '0%';\n        this.progressText.textContent = '0%';\n        this.progressDetails.textContent = '';\n    }\n\n    /**\n     * 显示进度条\n     */\n    show() {\n        this.progressContainer.style.display = 'block';\n    }\n\n    /**\n     * 隐藏进度条\n     */\n    hide() {\n        this.progressContainer.style.display = 'none';\n    }\n}\n","/**\n * 日志记录器组件\n */\nexport class Logger {\n    /**\n     * 创建日志记录器\n     * @param {HTMLElement} container - 日志容器元素\n     */\n    constructor(container) {\n        this.container = container;\n    }\n\n    /**\n     * 记录日志消息\n     * @param {string} message - 日志消息\n     * @param {string} type - 日志类型 (info, warning, error, success)\n     */\n    log(message, type = 'info') {\n        if (!this.container) return;\n\n        const logEntry = document.createElement('div');\n        logEntry.className = `log-entry ${type}`;\n        logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;\n        this.container.appendChild(logEntry);\n        this.container.scrollTop = this.container.scrollHeight;\n    }\n}\n","/**\n * 表格渲染器组件\n */\nexport class TableRenderer {\n    /**\n     * 创建表格渲染器\n     * @param {HTMLElement} container - 表格容器元素\n     */\n    constructor(container) {\n        this.container = container;\n    }\n\n    /**\n     * 获取Excel列名\n     * @param {number} index - 列索引\n     * @returns {string} - 列名（如A, B, AA等）\n     */\n    getExcelColumnName(index) {\n        let columnName = '';\n        while (index >= 0) {\n            columnName = String.fromCharCode(65 + (index % 26)) + columnName;\n            index = Math.floor(index / 26) - 1;\n        }\n        return columnName;\n    }\n\n    /**\n     * 直接更新DOM中的单元格内容，而不重新渲染整个表格\n     * @param {number} rowIndex 行索引\n     * @param {number} colIndex 列索引\n     * @param {string} text 新的单元格内容\n     * @param {number} headerRowsCount 头部行数量\n     */\n    updateCellInDOM(rowIndex, colIndex, text, headerRowsCount) {\n        if (!this.container) return;\n        \n        const tableWrapper = this.container.querySelector('.table-wrapper');\n        if (!tableWrapper) return;\n        \n        const table = tableWrapper.querySelector('table');\n        if (!table) return;\n        \n        // 如果是头部行，不进行更新\n        if (rowIndex < headerRowsCount) return;\n        \n        // 遍历所有行，找到对应的行\n        const rows = table.querySelectorAll('tr');\n        let targetRow = undefined;\n        \n        for (let i = 0; i < rows.length; i++) {\n            const row = rows[i];\n            const rowNumberCell = row.querySelector('.row-number');\n            if (rowNumberCell && rowNumberCell.textContent === (rowIndex + 1).toString()) {\n                targetRow = row;\n                break;\n            }\n        }\n        \n        if (!targetRow) return;\n        \n        // 找到对应的单元格，注意第一列是行号，所以需要+1\n        if (colIndex + 1 < targetRow.children.length) {\n            const cell = targetRow.children[colIndex + 1];\n            if (cell) {\n                cell.textContent = text;\n            }\n        }\n    }\n\n    /**\n     * 渲染表格\n     * @param {Object} sheetData - 工作表数据\n     * @param {Array} sheetData.headerRows - 头部行\n     * @param {Array} sheetData.rows - 数据行\n     * @param {Function} onCellEdit - 单元格编辑回调\n     */\n    renderTable(sheetData, onCellEdit) {\n        if (!this.container) return;\n\n        // 清空现有内容\n        this.container.innerHTML = '';\n        \n        // 创建表格容器，使用固定头的布局\n        const tableWrapper = document.createElement('div');\n        tableWrapper.className = 'table-wrapper';\n\n        const table = document.createElement('table');\n        table.className = 'excel-table';\n\n        const { headerRows, rows } = sheetData;\n        const allRows = [...headerRows, ...rows];\n\n        // 计算最大列数\n        const maxColumns = Math.max(\n            ...headerRows.map(row => row.length),\n            ...rows.map(row => row.length)\n        );\n\n        // 创建列号行\n        const colNumberRow = document.createElement('tr');\n        const emptyTh = document.createElement('th'); // 左上角空单元格\n        colNumberRow.appendChild(emptyTh);\n        \n        for (let i = 0; i < maxColumns; i++) {\n            const th = document.createElement('th');\n            th.textContent = this.getExcelColumnName(i);\n            th.className = 'column-header';\n            colNumberRow.appendChild(th);\n        }\n        table.appendChild(colNumberRow);\n\n        // 创建表格内容\n        allRows.forEach((row, rowIndex) => {\n            const tr = document.createElement('tr');\n            \n            // 如果不是第二行（索引为1），并且是在前6行内，则隐藏\n            if (rowIndex !== 1 && rowIndex < 6) {\n                tr.style.display = 'none';\n                return;\n            }\n\n            // 添加行号\n            const rowNumberCell = document.createElement('td');\n            rowNumberCell.textContent = (rowIndex + 1).toString();\n            rowNumberCell.className = 'row-number';\n            tr.appendChild(rowNumberCell);\n\n            // 添加数据单元格\n            for (let colIndex = 0; colIndex < maxColumns; colIndex++) {\n                const td = document.createElement(rowIndex < headerRows.length ? 'th' : 'td');\n                td.textContent = row[colIndex] || '';\n                \n                // 设置单元格可编辑\n                if (rowIndex >= headerRows.length) {\n                    td.contentEditable = 'true';\n                }\n                \n                // 添加单元格编辑事件\n                td.addEventListener('input', () => {\n                    onCellEdit(rowIndex, colIndex, td.textContent || '');\n                });\n\n                tr.appendChild(td);\n            }\n\n            table.appendChild(tr);\n        });\n\n        tableWrapper.appendChild(table);\n        this.container.appendChild(tableWrapper);\n        \n        // 添加CSS样式使行号和列头固定\n        this.addTableStyles();\n    }\n\n    /**\n     * 添加表格样式\n     */\n    addTableStyles() {\n        const styleId = 'fixed-table-style';\n        if (!document.getElementById(styleId)) {\n            const style = document.createElement('style');\n            style.id = styleId;\n            style.textContent = `\n                .table-wrapper {\n                    position: relative;\n                    overflow: auto;\n                    height: 99vh;\n                    max-width: 100%;\n                    border: 1px solid #ccc;\n                    margin: 1px;\n                    scroll-padding-top: 40px; /* 添加滚动填充，防止内容被固定头部遮挡 */\n                }\n                \n                .excel-table {\n                    border-collapse: collapse;\n                }\n                \n                .excel-table th, .excel-table td {\n                    border: 1px solid #ddd;\n                    padding: 8px;\n                    min-width: 100px;\n                }\n                \n                .excel-table th:first-child {\n                    position: sticky;\n                    left: 0;\n                    z-index: 3;\n                    background-color: #f2f2f2;\n                }\n                \n                .excel-table thead th {\n                    position: sticky;\n                    top: 0;\n                    z-index: 2;\n                    background-color: #f2f2f2;\n                    box-shadow: 0 1px 0 rgba(0,0,0,0.1); /* 添加底部阴影，增强视觉效果 */\n                }\n                \n                .excel-table tr:first-child th {\n                    position: sticky;\n                    top: 0;\n                    z-index: 2;\n                    background-color: #f2f2f2;\n                    box-shadow: 0 1px 0 rgba(0,0,0,0.1); /* 添加底部阴影，增强视觉效果 */\n                }\n                \n                /* 处理左上角单元格，同时固定在顶部和左侧 */\n                .excel-table tr:first-child th:first-child {\n                    position: sticky;\n                    top: 0;\n                    left: 0;\n                    z-index: 4; /* 最高层级，确保始终显示在最上层 */\n                    background-color: #f2f2f2;\n                    box-shadow: 1px 1px 0 rgba(0,0,0,0.1); /* 添加右侧和底部阴影 */\n                }\n                \n                .excel-table .row-number {\n                    position: sticky;\n                    left: 0;\n                    z-index: 1;\n                    background-color: #f2f2f2;\n                }\n            `;\n            document.head.appendChild(style);\n        }\n    }\n}\n","import fetch from 'node-fetch';\nimport { QdrantClient } from '@qdrant/qdrant-js';\nimport crypto from 'crypto'; // 导入crypto模块\n// 不再使用 dotenv/config，在服务器启动时已加载环境变量\n\n// 单例实例\nlet instance = null;\n\nexport class OllamaEmbeddingService {\n    constructor(\n        ollamaUrl = process.env.OLLAMA_URL || 'http://172.16.1.65:11434',\n        modelName = 'bge-m3:latest',\n        qdrantUrl = process.env.QDRANT_URL || 'http://172.16.0.78:6333',\n        collectionName = 'translation_embeddings',\n        vectorSize = 1024\n    ) {\n        // 如果已经有实例，直接返回\n        if (instance) {\n            console.log('已经存在 OllamaEmbeddingService 实例，返回现有实例');\n            return instance;\n        }\n        \n        console.log('初始化 OllamaEmbeddingService');\n        this.ollamaUrl = ollamaUrl;\n        this.modelName = modelName;\n        this.collectionName = collectionName;\n        this.vectorSize = vectorSize;\n        this.qdrantUrl = qdrantUrl;\n        \n        // 初始化Qdrant客户端\n        this.qdrantClient = new QdrantClient({\n            url: this.qdrantUrl,\n            checkCompatibility: false,  // 禁用版本兼容性检查，避免连接问题\n            timeout: 15000,  // 增加超时时间到15秒\n            retries: 3       // 添加重试次数\n        });\n        \n        console.log(`实际使用的Qdrant URL: ${qdrantUrl}`);\n        console.log(`实际使用的Ollama URL: ${ollamaUrl}`);\n        \n        // 保存实例\n        instance = this;\n    }\n\n    /**\n     * 初始化向量数据库集合\n     */\n    async initializeCollection() {\n        let retries = 2; // 重试次数\n        let delay = 1000; // 初始延迟时间（毫秒）\n        \n        while (retries >= 0) {\n            try {\n                console.log(`尝试初始化Qdrant集合 (剩余重试: ${retries})...`);\n                \n                // 检查集合是否存在\n                const collections = await this.qdrantClient.getCollections();\n                const collectionExists = collections.collections.some(c => c.name === this.collectionName);\n\n                if (!collectionExists) {\n                    // 创建新集合\n                    console.log(`创建新集合: ${this.collectionName}, 向量维度: ${this.vectorSize}`);\n                    await this.qdrantClient.createCollection(this.collectionName, {\n                        vectors: {\n                            size: this.vectorSize,\n                            distance: 'Cosine'\n                        }\n                    });\n                    console.log(`成功创建集合: ${this.collectionName}`);\n                } else {\n                    console.log(`集合已存在: ${this.collectionName}`);\n                    \n                    // 检查集合的向量维度是否匹配\n                    try {\n                        const collectionInfo = await this.qdrantClient.getCollection(this.collectionName);\n                        const vectorSize = collectionInfo.config?.params?.vectors?.size;\n                        \n                        if (vectorSize && vectorSize !== this.vectorSize) {\n                            console.warn(`警告: 集合 ${this.collectionName} 的向量维度 (${vectorSize}) 与当前配置 (${this.vectorSize}) 不匹配`);\n                        }\n                    } catch (infoError) {\n                        console.error('获取集合信息失败:', infoError.message);\n                    }\n                }\n                return true;\n            } catch (error) {\n                console.error(`初始化向量数据库集合失败 (剩余重试: ${retries}):`, error.message);\n                \n                // 提供更详细的错误信息\n                if (error.message.includes('ECONNREFUSED')) {\n                    console.error(`无法连接到Qdrant服务，请确保Qdrant服务正在运行于: ${this.qdrantUrl}`);\n                } else if (error.message.includes('fetch failed')) {\n                    console.error(`Qdrant服务请求失败，可能是网络问题或服务未启动: ${this.qdrantUrl}`);\n                }\n                \n                if (retries > 0) {\n                    console.log(`将在 ${delay/1000} 秒后重试初始化集合...`);\n                    await new Promise(resolve => setTimeout(resolve, delay));\n                    delay *= 2; // 指数退避策略\n                    retries--;\n                } else {\n                    console.error('初始化向量数据库集合失败，已达到最大重试次数');\n                    return false;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * 使用Ollama生成文本嵌入向量\n     */\n    async generateEmbedding(text) {\n        try {\n            if (!text || typeof text !== 'string' || text.trim() === '') {\n                console.error('无效的文本输入:', text);\n                throw new Error('无效的文本输入');\n            }\n            \n            const requestBody = {\n                model: this.modelName,\n                prompt: text.trim()\n            };\n            \n            console.log(`向Ollama发送嵌入请求 - 模型: ${this.modelName}, 文本长度: ${text.length}`);\n            console.log('嵌入请求体:', JSON.stringify(requestBody, null, 2));\n            \n            const response = await fetch(`${this.ollamaUrl}/api/embeddings`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json; charset=UTF-8'\n                },\n                body: JSON.stringify(requestBody)\n            });\n            \n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(`嵌入API错误 - 状态码: ${response.status}, 错误信息:`, errorText);\n                throw new Error(`嵌入API错误: ${response.status}`);\n            }\n            \n            const responseText = await response.text();\n            //console.log('嵌入API原始响应:', responseText);\n            \n            const data = JSON.parse(responseText);\n            console.log(`嵌入响应数据 - 向量长度: ${data.embedding ? data.embedding.length : 'undefined'}`);\n            \n            if (!data.embedding || !Array.isArray(data.embedding)) {\n                console.error('嵌入响应格式错误:', data);\n                throw new Error('嵌入响应格式错误');\n            }\n            \n            return { embedding: data.embedding };\n        } catch (error) {\n            console.error('生成嵌入向量失败:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * 存储嵌入向量到Qdrant\n     */\n    async storeEmbedding(text, metadata) {\n        try {\n            const embedding = await this.generateEmbedding(text);\n            \n            if (embedding === null) {\n                console.error('生成嵌入向量失败，无法存储');\n                return { success: false, id: null };\n            }\n            \n            // 使用UUID作为ID\n            const uuid = crypto.randomUUID();\n            \n            await this.qdrantClient.upsert(this.collectionName, {\n                wait: true,\n                points: [\n                    {\n                        id: uuid,\n                        vector: embedding.embedding,\n                        payload: {\n                            text,\n                            ...metadata\n                        }\n                    }\n                ]\n            });\n            \n            console.log(`成功存储嵌入向量: ${uuid}, 类型: ${metadata.type || '未指定'}`);\n            return { success: true, id: uuid };\n        } catch (error) {\n            console.error('存储嵌入向量失败:', error);\n            // 不抛出错误，而是返回失败状态\n            return { success: false, id: null };\n        }\n    }\n\n    /**\n     * 存储完整翻译条目的向量（包含中文和英文向量）\n     * @param {Object} entry - 完整的翻译条目，包含所有语言\n     * @returns {Object} - 包含操作结果和向量ID的对象\n     */\n    async storeEntryVectors(entry) {\n        try {\n            // 检查集合是否存在，如果不存在则初始化\n            try {\n                const collections = await this.qdrantClient.getCollections();\n                const collectionExists = collections.collections.some(c => c.name === this.collectionName);\n                \n                if (!collectionExists) {\n                    console.log(`集合不存在，正在创建: ${this.collectionName}`);\n                    await this.initializeCollection();\n                }\n            } catch (collectionError) {\n                console.error('检查集合时出错:', collectionError);\n                await this.initializeCollection();\n            }\n            \n            // 生成UUID作为向量ID\n            const uuid = crypto.randomUUID();\n            \n            // 准备元数据\n            const payload = {\n                Chinese: entry.Chinese || '',\n                English: entry.English || '',\n                Japanese: entry.Japanese || '',\n                Korean: entry.Korean || '',\n                Spanish: entry.Spanish || '',\n                French: entry.French || '',\n                German: entry.German || '',\n                Russian: entry.Russian || '',\n                Thai: entry.Thai || '',\n                Italian: entry.Italian || '',\n                Indonesian: entry.Indonesian || '',\n                Portuguese: entry.Portuguese || ''\n            };\n            \n            // 生成中文和英文的向量嵌入\n            let vector_cn = null;\n            let vector_en = null;\n            \n            if (entry.Chinese && entry.Chinese.trim() !== '') {\n                try {\n                    const cnEmbedding = await this.generateEmbedding(entry.Chinese);\n                    vector_cn = cnEmbedding.embedding;\n                } catch (cnError) {\n                    console.error('生成中文向量失败:', cnError);\n                }\n            }\n            \n            if (entry.English && entry.English.trim() !== '') {\n                try {\n                    const enEmbedding = await this.generateEmbedding(entry.English);\n                    vector_en = enEmbedding.embedding;\n                } catch (enError) {\n                    console.error('生成英文向量失败:', enError);\n                }\n            }\n            \n            // 如果没有成功生成任何向量，则返回失败\n            if (!vector_cn && !vector_en) {\n                console.error('无法为条目生成向量嵌入:', entry.Chinese || entry.English || '未知条目');\n                return { success: false, id: null, error: '无法生成向量嵌入' };\n            }\n            \n            const point = {\n                id: uuid,\n                // 如果中文向量存在则使用中文向量，否则使用英文向量\n                vector: vector_cn || vector_en,\n                payload: {\n                    ...payload\n                }\n            };\n            \n            // 如果存在中文和英文向量，则添加到payload中\n            if (vector_cn) {\n                point.payload.vector_cn = vector_cn;\n            }\n            if (vector_en) {\n                point.payload.vector_en = vector_en;\n            }\n\n            // 存储到Qdrant\n            try {\n                await this.qdrantClient.upsert(this.collectionName, {\n                    wait: true,\n                    points: [point]\n                });\n                \n                console.log(`成功存储翻译条目向量: ${uuid}`);\n                return { success: true, id: uuid };\n            } catch (upsertError) {\n                console.error('向Qdrant存储向量失败:', upsertError);\n                \n                // 尝试再次初始化集合并重试\n                try {\n                    console.log('尝试重新初始化集合并重试...');\n                    await this.initializeCollection();\n                    \n                    await this.qdrantClient.upsert(this.collectionName, {\n                        wait: true,\n                        points: [point]\n                    });\n                    \n                    console.log(`重试成功，已存储翻译条目向量: ${uuid}`);\n                    return { success: true, id: uuid };\n                } catch (retryError) {\n                    console.error('重试存储向量失败:', retryError);\n                    return { success: false, id: null, error: retryError.message };\n                }\n            }\n        } catch (error) {\n            console.error('存储翻译条目向量失败:', error);\n            return { success: false, id: null, error: error.message };\n        }\n    }\n\n    /**\n     * 更新翻译条目的向量\n     * @param {string} id - 要更新的向量ID\n     * @param {Object} entry - 完整的翻译条目，包含所有语言\n     * @returns {Object} - 包含操作结果和向量ID的对象\n     */\n    async updateEntryVectors(id, entry) {\n        try {\n            if (!id) {\n                // 如果没有ID，则创建新的向量\n                return await this.storeEntryVectors(entry);\n            }\n\n            if (!entry.Chinese && !entry.English) {\n                console.error('中文和英文内容均为空，无法更新向量');\n                return { success: false, id: null };\n            }\n\n            // 生成中文向量（如果有中文内容）\n            let vector_cn = null;\n            if (entry.Chinese) {\n                try {\n                    const cnEmbedding = await this.generateEmbedding(entry.Chinese);\n                    vector_cn = cnEmbedding.embedding;\n                } catch (cnError) {\n                    console.error('生成中文嵌入向量失败:', cnError);\n                }\n            }\n\n            // 生成英文向量（如果有英文内容）\n            let vector_en = null;\n            if (entry.English) {\n                try {\n                    const enEmbedding = await this.generateEmbedding(entry.English);\n                    vector_en = enEmbedding.embedding;\n                } catch (enError) {\n                    console.error('生成英文嵌入向量失败:', enError);\n                }\n            }\n\n            // 如果两个向量都生成失败，则返回失败\n            if (vector_cn === null && vector_en === null) {\n                return { success: false, id: null };\n            }\n\n            // 准备完整的payload数据\n            const payload = {\n                Chinese: entry.Chinese || '',\n                English: entry.English || '',\n                Japanese: entry.Japanese || '',\n                Korean: entry.Korean || '',\n                Spanish: entry.Spanish || '',\n                French: entry.French || '',\n                German: entry.German || '',\n                Russian: entry.Russian || '',\n                Thai: entry.Thai || '',\n                Italian: entry.Italian || '',\n                Indonesian: entry.Indonesian || '',\n                Portuguese: entry.Portuguese || ''\n            };\n\n            // 构建要更新的点\n            const point = {\n                id: id,\n                // 如果中文向量存在则使用中文向量，否则使用英文向量\n                vector: vector_cn || vector_en,\n                payload: payload\n            };\n\n            // 如果同时存在中文和英文向量，则添加到payload中\n            if (vector_cn && vector_en) {\n                point.payload.vector_cn = vector_cn;\n                point.payload.vector_en = vector_en;\n            }\n\n            // 更新Qdrant中的向量\n            await this.qdrantClient.upsert(this.collectionName, {\n                wait: true,\n                points: [point]\n            });\n            \n            console.log(`成功更新翻译条目向量: ${id}`);\n            return { success: true, id: id };\n        } catch (error) {\n            console.error('更新翻译条目向量失败:', error);\n            return { success: false, id: null };\n        }\n    }\n\n    /**\n     * 测试嵌入服务功能\n     * @returns {Promise<Object>} 测试结果\n     */\n    async testService() {\n        try {\n            console.log('开始测试嵌入服务...');\n            \n            // 检查Qdrant连接\n            await this.checkQdrantConnection();\n            \n            // 测试生成嵌入向量\n            const testText = \"这是一个测试文本，用于验证嵌入服务是否正常工作。\";\n            console.log(`测试文本: \"${testText}\"`);\n            \n            // 生成嵌入向量\n            const embedding = await this.generateEmbedding(testText);\n            console.log(`成功生成嵌入向量，维度: ${embedding.embedding.length}`);\n            \n            // 获取集合列表\n            const collections = await this.qdrantClient.getCollections();\n            console.log('Qdrant集合列表:', JSON.stringify(collections, null, 2));\n            \n            // 检查集合是否存在\n            const collectionExists = collections.collections.some(c => c.name === this.collectionName);\n            console.log(`集合 ${this.collectionName} ${collectionExists ? '存在' : '不存在'}`);\n            \n            console.log('嵌入服务测试成功');\n            \n            return {\n                success: true,\n                embeddingDimension: embedding.embedding.length,\n                collections: collections.collections.map(c => c.name)\n            };\n        } catch (error) {\n            console.error('嵌入服务测试失败:', error);\n            return {\n                success: false,\n                error: error.message || '未知错误'\n            };\n        }\n    }\n\n    /**\n     * 检查Qdrant连接是否可用\n     * @returns {Promise<boolean>} 连接是否可用\n     */\n    async checkQdrantConnection() {\n        let retries = 2; // 重试次数\n        let delay = 1000; // 初始延迟时间（毫秒）\n        \n        while (retries >= 0) {\n            try {\n                console.log(`检查Qdrant连接... (剩余重试次数: ${retries})`);\n                // 尝试获取集合列表来验证连接\n                const collections = await this.qdrantClient.getCollections();\n                console.log('Qdrant连接成功，可用集合:', collections.collections?.map(c => c.name).join(', ') || '无');\n                return true;\n            } catch (error) {\n                console.error(`Qdrant连接尝试失败 (剩余重试: ${retries}):`, error.message);\n                \n                // 提供更详细的错误信息\n                if (error.message.includes('ECONNREFUSED')) {\n                    console.error(`无法连接到Qdrant服务，请确保Qdrant服务正在运行于: ${this.qdrantUrl}`);\n                } else if (error.message.includes('fetch failed')) {\n                    console.error(`Qdrant服务请求失败，可能是网络问题或服务未启动: ${this.qdrantUrl}`);\n                }\n                \n                if (retries > 0) {\n                    console.log(`将在 ${delay/1000} 秒后重试...`);\n                    await new Promise(resolve => setTimeout(resolve, delay));\n                    delay *= 2; // 指数退避策略\n                    retries--;\n                } else {\n                    console.error('Qdrant连接失败，已达到最大重试次数');\n                    return false;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * 搜索相似文本\n     * @param {string} text - 要搜索的文本\n     * @param {string} language - 语言类型，'chinese'或'english'\n     * @param {number} limit - 返回结果数量限制\n     * @returns {Promise<Array>} - 搜索结果数组\n     */\n    async searchSimilar(text, language = 'chinese', limit = 3) {\n        try {\n            if (!text || typeof text !== 'string' || text.trim() === '') {\n                console.error('搜索文本为空');\n                return [];\n            }\n            \n            console.log(`搜索相似文本: \"${text.substring(0, 30)}${text.length > 30 ? '...' : ''}\"`);\n            console.log(`搜索语言: ${language}`);\n            \n            // 生成文本的嵌入向量\n            let embedding;\n            try {\n                embedding = await this.generateEmbedding(text);\n                if (!embedding) {\n                    console.error('无法为搜索文本生成嵌入向量');\n                    return [];\n                }\n            } catch (embeddingError) {\n                console.error('生成嵌入向量失败:', embeddingError.message);\n                return [];\n            }\n            \n            // 执行向量搜索\n            let searchResults;\n            try {\n                // 检查Qdrant连接状态\n                const isConnected = await this.checkQdrantConnection();\n                if (!isConnected) {\n                    console.error('Qdrant服务不可用，无法执行向量搜索');\n                    return [];\n                }\n                \n                console.log(`执行向量搜索，集合: ${this.collectionName}, 向量维度: ${embedding.embedding.length}`);\n                \n                // 确定使用哪个向量字段\n                // 标准化语言参数，忽略大小写，只关注是否是英语\n                const isEnglish = typeof language === 'string' && language.toLowerCase().includes('english');\n                const vectorName = isEnglish ? 'vector_en' : 'vector_cn';\n                \n                console.log(`使用向量字段: ${vectorName}, 语言参数: ${language}, 是否英语: ${isEnglish}`);\n                \n                // 执行向量搜索\n                searchResults = await this.qdrantClient.search(this.collectionName, {\n                    vector: {name:vectorName, vector:embedding.embedding},\n                    limit:limit,\n                    with_payload: true,  // 确保返回完整的payload\n                });\n                \n                console.log(`搜索完成，找到 ${searchResults?.length || 0} 个结果`);\n            } catch (qdrantError) {\n                console.error('Qdrant搜索失败:', qdrantError.message);\n                \n                // 如果是连接错误，提供更详细的错误信息\n                if (qdrantError.message.includes('ECONNREFUSED')) {\n                    console.error('无法连接到Qdrant服务，请确保Qdrant服务正在运行');\n                } else if (qdrantError.message.includes('fetch failed')) {\n                    console.error(`Qdrant服务请求失败，可能是网络问题或服务未启动: ${this.qdrantUrl}`);\n                } else if (qdrantError.message.includes('collection not found')) {\n                    console.error(`集合 \"${this.collectionName}\" 不存在，请先创建集合`);\n                    // 尝试创建集合\n                    try {\n                        console.log(`尝试创建集合 \"${this.collectionName}\"...`);\n                        await this.initializeCollection();\n                    } catch (initError) {\n                        console.error('创建集合失败:', initError.message);\n                    }\n                }\n                else {\n                    console.error('Qdrant搜索失败:', qdrantError.data.status.error);\n                }\n                return [];\n            }\n            \n            if (!searchResults || searchResults.length === 0) {\n                console.log('未找到相似结果');\n                return [];\n            }\n            \n            // 处理搜索结果，确保包含所需字段\n            const processedResults = searchResults.map(result => {\n                // 确保payload存在\n                const payload = result.payload || {};\n                \n                // 计算相似度\n                let similarity = result.score;\n                // if (language === 'english' && payload.vector_en) {\n                //     similarity = this.calculateCosineSimilarity(embedding.embedding, payload.vector_en);\n                // } else if (language === 'chinese' && payload.vector_cn) {\n                //     similarity = this.calculateCosineSimilarity(embedding.embedding, payload.vector_cn);\n                // }\n                \n                // 返回处理后的结果\n                return {\n                    ...result,\n                    score: similarity,\n                    payload: {\n                        id: payload.id,\n                        Chinese: payload.Chinese || payload.chinese || '',\n                        English: payload.English || payload.english || '',\n                        Japanese: payload.Japanese || '',\n                        Korean: payload.Korean || '',\n                        Spanish: payload.Spanish || '',\n                        French: payload.French || '',\n                        German: payload.German || '',\n                        Russian: payload.Russian || '',\n                        Thai: payload.Thai || '',\n                        Italian: payload.Italian || '',\n                        Indonesian: payload.Indonesian || '',\n                        Portuguese: payload.Portuguese || ''\n                    }\n                };\n            });\n            \n            // 按相似度排序\n            processedResults.sort((a, b) => b.score - a.score);\n            \n            console.log(`找到 ${processedResults.length} 条相似结果`);\n            return processedResults;\n        } catch (error) {\n            console.error('搜索相似文本失败:', error);\n            return [];\n        }\n    }\n    \n    /**\n     * 计算两个向量之间的余弦相似度\n     * @param {Array} vec1 - 第一个向量\n     * @param {Array} vec2 - 第二个向量\n     * @returns {number} - 余弦相似度，范围在-1到1之间\n     */\n    calculateCosineSimilarity(vec1, vec2) {\n        if (!vec1 || !vec2 || vec1.length !== vec2.length) {\n            return 0;\n        }\n        \n        let dotProduct = 0;\n        let norm1 = 0;\n        let norm2 = 0;\n        \n        for (let i = 0; i < vec1.length; i++) {\n            dotProduct += vec1[i] * vec2[i];\n            norm1 += vec1[i] * vec1[i];\n            norm2 += vec2[i] * vec2[i];\n        }\n        \n        norm1 = Math.sqrt(norm1);\n        norm2 = Math.sqrt(norm2);\n        \n        if (norm1 === 0 || norm2 === 0) {\n            return 0;\n        }\n        \n        return dotProduct / (norm1 * norm2);\n    }\n\n    /**\n     * 删除嵌入向量\n     */\n    async deleteEmbedding(id) {\n        try {\n            await this.qdrantClient.delete(this.collectionName, {\n                wait: true,\n                points: [id]\n            });\n            \n            return true;\n        } catch (error) {\n            console.error('删除嵌入向量失败:', error);\n            // 不抛出错误，而是返回失败状态\n            return false;\n        }\n    }\n\n    /**\n     * 将文本添加到向量存储\n     * @param {string} text - 要添加的文本\n     * @param {string} language - 文本语言，'chinese'或'english'\n     * @param {Object} metadata - 元数据\n     * @returns {Promise<string>} - 添加的记录ID\n     */\n    async addToVectorStore(text, language = 'chinese', metadata = {}) {\n        try {\n            if (!text || typeof text !== 'string' || text.trim() === '') {\n                console.error('添加到向量存储的文本为空');\n                throw new Error('文本为空');\n            }\n            \n            console.log(`添加文本到向量存储: \"${text.substring(0, 30)}${text.length > 30 ? '...' : ''}\", 语言: ${language}`);\n            \n            // 生成文本的嵌入向量\n            const embedding = await this.generateEmbedding(text);\n            if (!embedding) {\n                throw new Error('无法生成嵌入向量');\n            }\n            \n            // 生成唯一ID\n            const uuid = crypto.randomUUID();\n            \n            // 将文本和向量添加到Qdrant\n            await this.qdrantClient.upsert(this.collectionName, {\n                points: [\n                    {\n                        id: uuid,\n                        vector: embedding.embedding,\n                        payload: {\n                            text,\n                            ...metadata\n                        }\n                    }\n                ]\n            });\n            \n            console.log(`成功添加文本到向量存储，ID: ${uuid}`);\n            return uuid;\n        } catch (error) {\n            console.error('添加文本到向量存储失败:', error);\n            throw error;\n        }\n    }\n\n    /**\n     * 删除指定ID的向量\n     * @param {string} id - 向量ID\n     * @returns {Promise<boolean>} - 删除是否成功\n     */\n    async deleteVector(id) {\n        try {\n            if (!id) {\n                console.error('删除向量失败: ID为空');\n                return false;\n            }\n\n            console.log(`删除向量: ${id}`);\n            \n            // 检查Qdrant连接状态\n            const isConnected = await this.checkQdrantConnection();\n            if (!isConnected) {\n                console.error('Qdrant服务不可用，无法删除向量');\n                return false;\n            }\n            \n            // 删除向量\n            await this.qdrantClient.delete(this.collectionName, {\n                points: [id],\n            });\n            \n            console.log(`成功删除向量: ${id}`);\n            return true;\n        } catch (error) {\n            console.error(`删除向量失败: ${error.message}`);\n            return false;\n        }\n    }\n}\n","import { OllamaEmbeddingService } from './embedding.js';\n\n// 创建单例实例\nconsole.log('创建 OllamaEmbeddingService 单例实例');\nexport const embeddingService = new OllamaEmbeddingService();\nconsole.log('OllamaEmbeddingService 单例实例创建完成');\n","/**\n * 语言工具类\n */\nexport class LanguageUtils {\n    /**\n     * 获取源语言列表\n     * @returns {Array} - 源语言列表\n     */\n    static getSourceLanguages() {\n        return ['Chinese', 'English'];\n    }\n\n    /**\n     * 获取源语言配置\n     * @returns {Object} - 源语言配置对象\n     */\n    static getSourceLanguageConfig() {\n        return {\n            'Chinese': 'Chinese',\n            'English': 'English'\n        };\n    }\n\n    /**\n     * 获取语言映射\n     * @returns {Array} - 语言映射数组\n     */\n    static getLanguageMappings() {\n        return [\n            { columnHeader: '英语', targetLang: 'English' },\n            { columnHeader: '日语', targetLang: 'Japanese' },\n            { columnHeader: '韩语', targetLang: 'Korean' },\n            { columnHeader: '西班牙语', targetLang: 'Spanish' },\n            { columnHeader: '法语', targetLang: 'French' },\n            { columnHeader: '德语', targetLang: 'German' },\n            { columnHeader: '俄语', targetLang: 'Russian' },\n            { columnHeader: '泰语', targetLang: 'Thai' },\n            { columnHeader: '意大利语', targetLang: 'Italian' },\n            { columnHeader: '印尼语', targetLang: 'Indonesian' },\n            { columnHeader: '葡萄牙语', targetLang: 'Portuguese' }\n        ];\n    }\n\n    /**\n     * 获取语言显示名称\n     * @param {string} langCode - 语言代码\n     * @returns {string} - 语言显示名称\n     */\n    static getLanguageDisplayName(langCode) {\n        // 简单返回语言代码，因为我们不再使用详细的映射\n        return langCode;\n    }\n\n    /**\n     * 获取API语言代码\n     * @param {string} langCode - 语言代码\n     * @returns {string} - API语言代码\n     */\n    static getApiLanguageCode(langCode) {\n        // 将简写语言代码转换为API需要的全拼语言名称\n        if (!langCode) return '';\n        \n        const languageCodeMap = {\n            'zh': 'Chinese',\n            'en': 'English',\n            'ja': 'Japanese',\n            'ko': 'Korean',\n            'es': 'Spanish',\n            'fr': 'French',\n            'de': 'German',\n            'ru': 'Russian',\n            'th': 'Thai',\n            'it': 'Italian',\n            'id': 'Indonesian',\n            'pt': 'Portuguese'\n        };\n        \n        return languageCodeMap[langCode] || langCode;\n    }\n\n    /**\n     * 根据列标题查找语言\n     * @param {string} columnHeader - 列标题\n     * @returns {string|null} - 语言代码或null\n     */\n    static findLanguageByColumnHeader(columnHeader) {\n        if (!columnHeader) return null;\n        \n        const mappings = this.getLanguageMappings();\n        for (const mapping of mappings) {\n            if (mapping.columnHeader === columnHeader) {\n                return mapping.targetLang;\n            }\n        }\n        \n        // 特殊处理源语言\n        if (columnHeader === '简体中文' || columnHeader === '中文') {\n            return 'Chinese';\n        }\n        \n        return null;\n    }\n}\n","/**\n * 翻译服务类\n */\nimport { embeddingService } from './embedding-instance.js';\nimport fetch from 'node-fetch';\nimport { LanguageUtils } from '../utils/LanguageUtils.js';\n\nexport class TranslationService {\n    /**\n     * 创建翻译服务实例\n     * @param {string} apiKey - API密钥\n     * @param {Function} logCallback - 日志回调函数\n     */\n    constructor(apiKey, logCallback) {\n        this.apiEndpoint = 'https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions';\n        // 优先使用传入的API密钥，如果没有则使用环境变量中的密钥\n        this.apiKey = apiKey || process.env.ALI_API_KEY || '';\n        this.logCallback = logCallback || console.log;\n        this.shouldStopTranslation = false;\n        \n        if (this.apiKey) {\n            console.log('已成功加载API密钥');\n        }\n    }\n\n    /**\n     * 停止翻译\n     */\n    stopTranslation() {\n        this.shouldStopTranslation = true;\n    }\n\n    /**\n     * 重置停止标志\n     */\n    resetStopFlag() {\n        this.shouldStopTranslation = false;\n    }\n\n    /**\n     * 从知识库中获取翻译记忆\n     * @param {string} text - 源文本\n     * @param {string} sourceLanguage - 源语言\n     * @param {string} targetLanguage - 目标语言\n     * @returns {Promise<Array>} - 翻译记忆列表\n     */\n    async getTranslationMemory(text, sourceLanguage, targetLanguage) {\n        try {\n            if (!text || text.trim() === '') {\n                return [];\n            }\n\n            // 将语言代码转换为标准格式\n            const standardSourceLang = LanguageUtils.getApiLanguageCode(sourceLanguage);\n            const standardTargetLang = LanguageUtils.getApiLanguageCode(targetLanguage);\n\n            // 确定向量搜索的语言类型\n            const vectorLanguage = standardSourceLang === 'Chinese' ? 'chinese' : 'english';\n            \n            try {\n                // 搜索相似的翻译条目\n                const similarEntries = await embeddingService.searchSimilar(text, vectorLanguage, 3);\n                \n                // 如果没有找到相似条目，返回空数组\n                if (!similarEntries || similarEntries.length === 0) {\n                    console.log('未找到相似的翻译记忆');\n                    return [];\n                }\n                \n                // 确定源语言和目标语言在数据库中的字段名\n                const sourceField = standardSourceLang;\n                const targetField = standardTargetLang;\n                \n                console.log(`构建翻译记忆 - 源语言字段: ${sourceField}, 目标语言字段: ${targetField}`);\n                \n                // 构建翻译记忆列表\n                const tmList = [];\n                \n                for (const entry of similarEntries) {\n                    // 检查payload是否存在\n                    if (!entry.payload) {\n                        console.log('跳过翻译记忆: payload为空');\n                        continue;\n                    }\n                    \n                    // 输出完整的payload以便调试\n                    console.log('翻译记忆条目payload:', JSON.stringify(entry.payload));\n                    \n                    // 处理字段名大小写问题：同时检查首字母大写和首字母小写的字段\n                    const sourceFieldLower = sourceField.toLowerCase();\n                    const targetFieldLower = targetField.toLowerCase();\n                    \n                    // 尝试获取源语言和目标语言的值（考虑大小写）\n                    let source = entry.payload[sourceField];\n                    let target = entry.payload[targetField];\n                    \n                    // 如果使用首字母大写的字段名没有找到值，尝试使用首字母小写的字段名\n                    if (!source && entry.payload[sourceFieldLower]) {\n                        source = entry.payload[sourceFieldLower];\n                        console.log(`使用小写字段名找到源语言值: ${sourceFieldLower}`);\n                    }\n                    \n                    if (!target && entry.payload[targetFieldLower]) {\n                        target = entry.payload[targetFieldLower];\n                        console.log(`使用小写字段名找到目标语言值: ${targetFieldLower}`);\n                    }\n                    \n                    // 输出源语言和目标语言的值以便调试\n                    console.log(`源语言(${sourceField}/${sourceFieldLower})值: \"${source}\", 目标语言(${targetField}/${targetFieldLower})值: \"${target}\"`);\n                    \n                    // 只有当源和目标都有值时才添加到翻译记忆\n                    if (source && target && source.trim() !== '' && target.trim() !== '') {\n                        tmList.push({\n                            source: source,\n                            target: target\n                        });\n                        console.log(`添加翻译记忆: ${source} -> ${target}`);\n                    } else {\n                        if (!source || source.trim() === '') {\n                            console.log(`跳过翻译记忆: 源语言字段为空`);\n                        }\n                        if (!target || target.trim() === '') {\n                            console.log(`跳过翻译记忆: 目标语言字段为空, payload中的字段: ${Object.keys(entry.payload).join(', ')}`);\n                            \n                            // 尝试检查是否有其他可能的目标语言字段\n                            const payloadKeys = Object.keys(entry.payload);\n                            const possibleTargetField = payloadKeys.find(key => \n                                key.toLowerCase() === targetField.toLowerCase() || \n                                key.toLowerCase().includes(targetField.toLowerCase())\n                            );\n                            \n                            if (possibleTargetField && possibleTargetField !== targetField && possibleTargetField !== targetFieldLower) {\n                                const possibleTarget = entry.payload[possibleTargetField];\n                                console.log(`找到可能的目标语言字段 ${possibleTargetField}, 值: \"${possibleTarget}\"`);\n                                \n                                if (possibleTarget && possibleTarget.trim() !== '') {\n                                    tmList.push({\n                                        source: source,\n                                        target: possibleTarget\n                                    });\n                                    console.log(`使用替代字段添加翻译记忆: ${source} -> ${possibleTarget}`);\n                                }\n                            }\n                        }\n                    }\n                }\n                \n                console.log(`找到 ${tmList.length} 条翻译记忆`);\n                return tmList;\n            } catch (vectorError) {\n                // 向量搜索失败，记录错误但不中断翻译流程\n                console.error('向量搜索失败，将跳过翻译记忆匹配:', vectorError.message);\n                return [];\n            }\n        } catch (error) {\n            console.error('获取翻译记忆失败:', error);\n            // 出错时返回空数组，允许翻译流程继续\n            return [];\n        }\n    }\n\n    /**\n     * 翻译批次\n     * @param {Object} batch - 翻译批次\n     * @param {string} sourceLanguage - 源语言\n     * @returns {Promise<boolean>} - 是否成功\n     */\n    async translateBatch(batch, sourceLanguage) {\n        try {\n            // 确保batch和batch.tasks存在\n            if (!batch || !batch.tasks || !Array.isArray(batch.tasks) || batch.tasks.length === 0) {\n                console.error('错误: 无效的批量翻译任务', batch);\n                this.logCallback('错误: 无效的批量翻译任务', 'error');\n                return false;\n            }\n            \n            // 获取批次的行号范围\n            const rowIndices = batch.tasks.map(task => task.rowIndex + 3); // +3 因为用户看到的Excel行号从1开始，加上有两行头部\n            const minRow = Math.min(...rowIndices);\n            const maxRow = Math.max(...rowIndices);\n            const rowRange = minRow === maxRow ? `第 ${minRow} 行` : `第 ${minRow} 行到第 ${maxRow} 行`;\n            \n            // 确保sourceLanguage和targetLang正确设置\n            const sourceLang = sourceLanguage || 'zh';\n            \n            // 检查目标语言是否存在\n            if (!batch.tasks[0].targetLang && !batch.tasks[0].targetLanguage && !batch.tasks[0].to) {\n                console.error('错误: 目标语言未定义', batch.tasks[0]);\n                this.logCallback('错误: 目标语言未定义', 'error');\n                return false;\n            }\n            \n            // 获取目标语言，优先使用targetLanguage字段\n            const targetLang = batch.tasks[0].targetLanguage || batch.tasks[0].targetLang || batch.tasks[0].to || 'en';\n            \n            this.logCallback(`开始翻译批次 ${batch.batchId} - ${sourceLang} 到 ${targetLang} - ${rowRange} - ${batch.tasks.length}个任务`, 'info');\n            \n            // 只在调试模式下打印详细任务信息\n            if (process.env.NODE_ENV === 'development') {\n                console.log(`开始翻译批次 - ${batch.tasks.length}个任务:`, batch.tasks);\n            }\n            \n            // 再次尝试从环境变量获取API密钥\n            if (!this.apiKey || (typeof this.apiKey === 'string' && this.apiKey.trim() === '')) {\n                if (process.env.ALI_API_KEY) {\n                    this.apiKey = process.env.ALI_API_KEY;\n                    console.log('从环境变量获取到API密钥');\n                } else {\n                    const error = new Error('错误：API密钥未设置');\n                    console.error(error);\n                    this.logCallback(error.message, 'error');\n                    throw error;\n                }\n            }\n            \n            // 过滤掉空文本任务或非字符串任务\n            const validTasks = batch.tasks.filter(task => {\n                try {\n                    // 如果任务文本不是字符串，尝试转换\n                    if (typeof task.text !== 'string') {\n                        console.error(`警告: 任务文本不是字符串，类型为 ${typeof task.text}`);\n                        if (task.text === null || task.text === undefined) {\n                            return false; // 跳过 null 或 undefined\n                        }\n                        // 尝试转换为字符串\n                        task.text = String(task.text);\n                    }\n                    return task.text.trim() !== '';\n                } catch (error) {\n                    console.error(`过滤任务时出错:`, error, task);\n                    return false; // 如果出错，跳过该任务\n                }\n            });\n            if (validTasks.length === 0) {\n                this.logCallback('批次中没有有效的翻译任务', 'warning');\n                return false;\n            }\n            \n            if (this.shouldStopTranslation) {\n                console.log('翻译被用户停止');\n                this.logCallback('翻译被用户停止', 'warning');\n                return false;\n            }\n\n            try {\n                // 检查是否有有效任务\n                if (validTasks.length === 0) {\n                    this.logCallback('没有有效的翻译任务', 'warning');\n                    return false;\n                }\n                \n                // 检查目标语言是否存在\n                if (!validTasks[0].targetLanguage && !validTasks[0].targetLang && !validTasks[0].to) {\n                    console.error('错误: 目标语言未定义', validTasks[0]);\n                    this.logCallback('错误: 目标语言未定义', 'error');\n                    return false;\n                }\n                \n                console.log(`翻译批次 - 目标语言: ${validTasks[0].targetLanguage || validTasks[0].targetLang || validTasks[0].to}, 共${validTasks.length}个任务`);\n                \n                // 获取目标语言，优先使用targetLanguage字段\n                const targetLang = validTasks[0].targetLanguage || validTasks[0].targetLang || validTasks[0].to;\n                \n                console.log(`翻译批次 - 目标语言: ${targetLang}, 共${validTasks.length}个任务`);\n                \n                // 如果批次中只有一个任务，使用单个翻译方法\n                if (validTasks.length === 1) {\n                    const task = validTasks[0];\n                    const success = await this.translateSingle(task, sourceLanguage);\n                    batch.success = success;\n                    return success;\n                }\n                \n                // 收集所有任务的文本和目标语言\n                const requestBody = {\n                    model: \"qwen-mt-turbo\",\n                    messages: [\n                        {\n                            role: \"user\",\n                            content: validTasks.map(t => t.text).join('\\n')\n                        }\n                    ],\n                    translation_options: {\n                        source_lang: LanguageUtils.getApiLanguageCode(sourceLang),\n                        target_lang: LanguageUtils.getApiLanguageCode(targetLang)\n                    },\n                    temperature: 0.7,\n                    max_tokens: 2000 // 增加最大token数限制，因为我们现在一次翻译多条\n                };\n                \n                // 打印请求体\n                console.log('发送翻译请求体:', JSON.stringify(requestBody, null, 2));\n                \n                const response = await fetch(this.apiEndpoint, {\n                    method: 'POST',\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Authorization': `Bearer ${typeof this.apiKey === 'string' ? this.apiKey.trim() : this.apiKey}`,\n                        'Accept': 'application/json'\n                    },\n                    body: JSON.stringify(requestBody)\n                });\n\n                if (!response.ok) {\n                    const errorText = await response.text();\n                    console.error(`翻译API错误 - 状态码: ${response.status}, 错误信息:`, errorText);\n                    this.logCallback(`翻译API错误: ${response.status} - ${errorText}`, 'error');\n                    throw new Error(`翻译API错误: ${response.status}`);\n                }\n\n                const responseText = await response.text();\n                \n                // 打印API响应\n                console.log('API原始响应:', responseText);\n                \n                const data = JSON.parse(responseText);\n                \n                // 打印解析后的数据\n                console.log('解析后的响应数据:', JSON.stringify(data, null, 2));\n                \n                if (!data.choices?.[0]?.message?.content) {\n                    console.error('翻译返回数据格式错误:', data);\n                    this.logCallback('翻译返回数据格式错误', 'error');\n                    throw new Error('翻译返回数据格式错误');\n                }\n\n                // 获取翻译结果并分配给每个任务\n                const translatedContent = data.choices[0].message.content;\n                const translatedLines = typeof translatedContent === 'string' ? \n                    translatedContent.trim().split('\\n') : \n                    [String(translatedContent)];\n                console.log(`收到 ${translatedLines.length} 行翻译结果，共 ${validTasks.length} 个任务`);\n                \n                // 确保翻译结果行数与任务数量匹配\n                const minLength = Math.min(translatedLines.length, validTasks.length);\n                \n                for (let i = 0; i < minLength; i++) {\n                    const translatedLine = translatedLines[i];\n                    // 设置translation字段而不是覆盖text字段\n                    validTasks[i].translation = typeof translatedLine === 'string' ? \n                        translatedLine.trim() : String(translatedLine);\n                    console.log(`翻译成功 - 行号: ${validTasks[i].rowIndex + 1}, 译文: ${validTasks[i].translation}`);\n                }\n                \n                // 如果翻译结果行数少于任务数量，记录错误\n                if (translatedLines.length < validTasks.length) {\n                    const missingCount = validTasks.length - translatedLines.length;\n                    this.logCallback(`警告: ${missingCount} 个任务没有收到翻译结果`, 'warning');\n                }\n                \n                // 标记翻译成功\n                batch.success = true;\n                return true;\n                \n            } catch (error) {\n                console.error(`批量翻译失败 - 批次 ${batch.batchId}`, error);\n                \n                // 打印批次信息以帮助调试\n                console.error('批次任务详情:', batch.tasks.map(task => ({\n                    rowIndex: task.rowIndex,\n                    text: task.text,\n                    textType: typeof task.text\n                })));\n                \n                this.logCallback(`翻译失败: ${error.message}`, 'error');\n                \n                // 标记翻译失败\n                batch.success = false;\n                return false;\n            }\n        } catch (error) {\n            console.error('翻译批次失败:', error);\n            this.logCallback(`翻译失败: ${error.message}`, 'error');\n            return false;\n        }\n    }\n\n    /**\n     * 翻译单个任务\n     * @param {Object} task - 翻译任务\n     * @param {string} sourceLanguage - 源语言\n     * @returns {Promise<boolean>} - 是否成功\n     */\n    async translateSingle(task, sourceLanguage) {\n        try {\n            // 确保sourceLanguage和targetLang正确设置\n            const sourceLang = sourceLanguage || (task.from === 'zh' ? 'Chinese' : 'English');\n            \n            // 处理目标语言，优先使用targetLanguage字段\n            const targetLang = task.targetLanguage || task.targetLang || task.to || 'English';\n            \n            console.log(`开始单个翻译 - 源语言: ${sourceLang}, 目标语言: ${targetLang}, 文本: ${task.text}`);\n            \n            // 获取翻译记忆\n            const tmList = await this.getTranslationMemory(task.text, sourceLang, targetLang);\n            \n            // 构建API请求体\n            const requestBody = {\n                model: \"qwen-mt-turbo\",\n                messages: [\n                    {\n                        role: \"user\",\n                        content: task.text\n                    }\n                ],\n                translation_options: {\n                    source_lang: LanguageUtils.getApiLanguageCode(sourceLang),\n                    target_lang: LanguageUtils.getApiLanguageCode(targetLang)\n                },\n                temperature: 0.7,\n                max_tokens: 1000\n            };\n            \n            // 如果有翻译记忆，添加到请求中\n            if (tmList && tmList.length > 0) {\n                requestBody.translation_options.tmList = tmList;\n                console.log(`使用 ${tmList.length} 条翻译记忆`);\n            }\n            \n            // 打印请求体\n            console.log('发送单个翻译请求体:', JSON.stringify(requestBody, null, 2));\n            \n            // 发送API请求\n            const response = await fetch(this.apiEndpoint, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'Authorization': `Bearer ${typeof this.apiKey === 'string' ? this.apiKey.trim() : this.apiKey}`,\n                    'Accept': 'application/json'\n                },\n                body: JSON.stringify(requestBody)\n            });\n            \n            if (!response.ok) {\n                const errorText = await response.text();\n                console.error(`单个翻译API错误 - 状态码: ${response.status}, 错误信息:`, errorText);\n                this.logCallback(`翻译API错误: ${response.status} - ${errorText}`, 'error');\n                throw new Error(`翻译API错误: ${response.status}`);\n            }\n            \n            const responseText = await response.text();\n            console.log('单个翻译API原始响应:', responseText);\n            \n            const data = JSON.parse(responseText);\n            console.log('单个翻译解析后的响应数据:', JSON.stringify(data, null, 2));\n            \n            if (!data.choices?.[0]?.message?.content) {\n                console.error('翻译返回数据格式错误:', data);\n                this.logCallback('翻译返回数据格式错误', 'error');\n                throw new Error('翻译返回数据格式错误');\n            }\n            \n            // 获取翻译结果\n            const translatedContent = data.choices[0].message.content;\n            task.text = typeof translatedContent === 'string' ? \n                translatedContent.trim() : String(translatedContent);\n            \n            console.log(`单个翻译成功 - 行号: ${task.rowIndex + 1}, 译文: ${task.text}`);\n            return true;\n            \n        } catch (error) {\n            console.error('单个翻译失败:', error);\n            this.logCallback(`翻译失败: ${error.message}`, 'error');\n            return false;\n        }\n    }\n}\n\n// 导出翻译服务实例\nexport const translationService = new TranslationService();\n","import { TranslationService, translationService } from './translator.js';\n\n/**\n * 翻译管理器\n */\nexport class TranslationManager {\n    /**\n     * 创建翻译管理器\n     * @param {string} apiKey - API密钥\n     * @param {Function} logCallback - 日志回调函数\n     * @param {Object} progressBar - 进度条对象\n     */\n    constructor(apiKey, logCallback, progressBar) {\n        this.apiKey = apiKey;\n        this.log = logCallback;\n        this.progressBar = progressBar;\n        this.shouldStopTranslation = false;\n    }\n\n    /**\n     * 停止翻译\n     */\n    stopTranslation() {\n        this.shouldStopTranslation = true;\n    }\n\n    /**\n     * 创建批次\n     * @param {Array} items - 项目数组\n     * @param {number} batchSize - 批次大小\n     * @returns {Array} - 批次数组\n     */\n    createBatches(items, batchSize) {\n        const batches = [];\n        for (let i = 0; i < items.length; i += batchSize) {\n            batches.push(items.slice(i, i + batchSize));\n        }\n        return batches;\n    }\n\n    /**\n     * 准备翻译任务\n     * @param {Array} rows - 数据行\n     * @param {number} sourceColumnIndex - 源文本列索引\n     * @param {Array} targetColumns - 目标列配置\n     * @returns {Array} - 翻译任务数组\n     */\n    prepareTranslationTasks(rows, sourceColumnIndex, targetColumns) {\n        const translationTasks = [];\n        \n        // 遍历所有行，收集需要翻译的任务\n        for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n            const row = rows[rowIndex];\n            \n            // 检查源文本是否存在\n            const sourceText = row[sourceColumnIndex];\n            if (!sourceText || typeof sourceText !== 'string' || sourceText.trim() === '') {\n                continue; // 跳过空源文本\n            }\n            \n            // 遍历所有目标列\n            for (const targetColumn of targetColumns) {\n                const targetColumnIndex = targetColumn.index;\n                // 使用targetLang属性，如果不存在则使用langCode属性\n                const targetLang = targetColumn.targetLang || targetColumn.langCode;\n                \n                // 检查目标单元格是否已有内容\n                const targetText = row[targetColumnIndex];\n                if (targetText && typeof targetText === 'string' && targetText.trim() !== '') {\n                    continue; // 跳过已有内容的目标单元格\n                }\n                \n                // 创建翻译任务\n                translationTasks.push({\n                    rowIndex,\n                    sourceColumnIndex,\n                    targetColumnIndex,\n                    targetLang,\n                    text: sourceText\n                });\n            }\n        }\n        \n        return translationTasks;\n    }\n    \n    /**\n     * 将任务按目标语言分组并组织成批次\n     * @param {Array} tasks - 翻译任务数组\n     * @param {number} batchSize - 批次大小\n     * @returns {Array} - 批次数组\n     */\n    organizeTasksIntoBatches(tasks, batchSize = 1) {\n        // 按目标语言分组\n        const tasksByLanguage = {};\n        for (const task of tasks) {\n            const lang = task.targetLang;\n            if (!tasksByLanguage[lang]) {\n                tasksByLanguage[lang] = [];\n            }\n            tasksByLanguage[lang].push(task);\n        }\n        \n        // 为每种语言创建批次\n        const batches = [];\n        let batchId = 1;\n        \n        for (const lang in tasksByLanguage) {\n            const langTasks = tasksByLanguage[lang];\n            const langBatches = this.createBatches(langTasks, batchSize);\n            \n            for (const batch of langBatches) {\n                batches.push({\n                    batchId: batchId++,\n                    tasks: batch,\n                    success: false,\n                    completed: 0\n                });\n            }\n        }\n        \n        return batches;\n    }\n    \n    /**\n     * 执行翻译过程\n     * @param {Array} rows - 数据行\n     * @param {number} sourceColumnIndex - 源列索引\n     * @param {string} sourceLang - 源语言\n     * @param {Array} targetColumns - 目标列数组\n     * @param {Function} updateCellCallback - 更新单元格回调函数\n     * @returns {Promise<void>}\n     */\n    async executeTranslation(rows, sourceColumnIndex, sourceLang, targetColumns, updateCellCallback) {\n        try {\n            // 1. 收集所有需要翻译的源文本和目标单元格\n            this.log('正在收集需要翻译的内容...', 'info');\n            const translationTasks = this.prepareTranslationTasks(rows, sourceColumnIndex, targetColumns);\n            \n            if (translationTasks.length === 0) {\n                this.log('没有找到需要翻译的内容', 'warning');\n                return;\n            }\n            \n            this.log(`找到 ${translationTasks.length} 个需要翻译的单元格`, 'info');\n            \n            // 2. 将任务按目标语言分组，然后每组最多20条\n            const batches = this.organizeTasksIntoBatches(translationTasks);\n            \n            // 3. 使用翻译服务实例\n            const translationService = new TranslationService(this.apiKey, this.log);\n            \n            // 4. 开始批量翻译\n            const totalBatches = batches.length;\n            let completedBatches = 0;\n            \n            this.log(`开始处理 ${totalBatches} 个翻译批次`, 'info');\n            \n            for (let i = 0; i < batches.length; i++) {\n                if (this.shouldStopTranslation) {\n                    this.log('翻译已被用户停止', 'warning');\n                    break;\n                }\n                \n                const batch = batches[i];\n                const currentBatchId = i + 1;\n                \n                // 更新进度\n                this.progressBar.updateBatchProgress({\n                    completedBatches,\n                    totalBatches,\n                    currentBatchId,\n                    completedTasksInCurrentBatch: 0,\n                    totalTasksInCurrentBatch: batch.tasks.length\n                });\n                \n                try {\n                    const success = await translationService.translateBatch(batch, sourceLang);\n                    completedBatches++;\n                    \n                    // 更新进度\n                    this.progressBar.updateBatchProgress({\n                        completedBatches,\n                        totalBatches,\n                        currentBatchId: 0, // 当前批次已完成\n                        completedTasksInCurrentBatch: batch.tasks.length,\n                        totalTasksInCurrentBatch: batch.tasks.length\n                    });\n                    \n                    // 只有翻译成功时才更新单元格\n                    if (success) {\n                        // 每个批次完成后更新单元格，但不重新渲染整个表格\n                        let tasksWithResults = 0;\n                        let tasksWithoutResults = 0;\n                        \n                        for (const task of batch.tasks) {\n                            // 只有当任务有翻译结果时才更新单元格\n                            if (task.text && typeof task.text === 'string' && task.text.trim() !== '') {\n                                // 更新数据模型\n                                rows[task.rowIndex][task.targetColumnIndex] = task.text;\n                                \n                                // 直接更新DOM中的单元格内容，而不是重新渲染整个表格\n                                updateCellCallback(task.rowIndex + 2, task.targetColumnIndex, task.text);\n                                tasksWithResults++;\n                            } else {\n                                tasksWithoutResults++;\n                            }\n                        }\n                        \n                        if (tasksWithoutResults > 0) {\n                            this.log(`警告: ${tasksWithoutResults} 个单元格未获得翻译结果`, 'warning');\n                        }\n                    }\n                    \n                    this.log(`批次 ${currentBatchId}/${totalBatches} 完成`, 'success');\n                } catch (error) {\n                    this.log(`批次 ${currentBatchId}/${totalBatches} 失败: ${error.message}`, 'error');\n                }\n            }\n            \n            this.log(`翻译任务完成: ${completedBatches}/${totalBatches} 个批次`, \n                completedBatches === totalBatches ? 'success' : 'warning');\n            \n        } catch (error) {\n            this.log(`翻译过程出错: ${error.message}`, 'error');\n            console.error('翻译过程出错:', error);\n        }\n    }\n}\n","import * as XLSX from 'xlsx';\nimport { ProgressBar } from './components/progress.js';\nimport { Logger } from './components/Logger.js';\nimport { TableRenderer } from './components/TableRenderer.js';\nimport { TranslationManager } from './services/TranslationManager.js';\nimport { LanguageUtils } from './utils/LanguageUtils.js';\nimport { readExcelFile, createExcelWorkbook } from './utils/excel.js';\n\n/**\n * Excel翻译器类\n */\nexport class ExcelTranslator {\n    // 静态属性，用于跟踪事件监听器是否已初始化\n    static _eventsInitialized = false;\n    \n    /**\n     * 创建Excel翻译器实例\n     */\n    constructor() {\n        console.log('ExcelTranslator 构造函数被调用');\n        \n        // 初始化UI元素\n        this.tableOutput = document.getElementById('tableOutput');\n        this.logOutput = document.getElementById('logOutput');\n        \n        // 初始化组件\n        this.logger = new Logger(this.logOutput);\n        this.progressBar = new ProgressBar();\n        this.tableRenderer = new TableRenderer(this.tableOutput);\n        \n        // 初始化数据\n        this.data = {};\n        this.currentSheet = null;\n        this.currentFileName = '';\n        this.apiKey = '';\n        this.shouldStopTranslation = false;\n        this.sourceLangSelect = null;\n        \n        // 优先从环境变量获取API密钥\n        if (process.env.ALI_API_KEY) {\n            this.apiKey = process.env.ALI_API_KEY;\n            console.log('已从环境变量加载API密钥');\n        }\n        \n        // 初始化UI和事件监听器\n        this.initializeUI();\n        this.initializeEventListeners();\n    }\n\n    /**\n     * 初始化UI\n     */\n    initializeUI() {\n        // 初始化进度条\n        this.progressBar.show();\n        this.progressBar.updateProgress({ current: 0, total: 100 });\n        this.progressBar.hide();\n\n        // 绑定停止按钮事件\n        const stopBtn = document.getElementById('stopTranslateBtn');\n        if (stopBtn) {\n            // 移除可能存在的旧事件监听器\n            const newStopBtn = stopBtn.cloneNode(true);\n            stopBtn.parentNode.replaceChild(newStopBtn, stopBtn);\n            \n            newStopBtn.addEventListener('click', () => {\n                this.shouldStopTranslation = true;\n                newStopBtn.disabled = true;\n                this.logger.log('正在停止翻译...', 'warning');\n            });\n        }\n    }\n\n    /**\n     * 初始化事件监听器\n     */\n    initializeEventListeners() {\n        console.log('initializeEventListeners 被调用', new Error().stack);\n        \n        // 防止重复注册事件监听器 - 使用静态属性\n        if (ExcelTranslator._eventsInitialized) {\n            console.log('事件监听器已初始化，跳过重复注册');\n            return;\n        }\n        \n        const fileInput = document.getElementById('fileInput');\n        const uploadBtn = document.getElementById('uploadBtn');\n        const translateBtn = document.getElementById('translateBtn');\n        const exportBtn = document.getElementById('exportBtn');\n        const actionButtons = document.getElementById('actionButtons');\n        this.sourceLangSelect = document.getElementById('sourceLang');\n\n        console.log('找到的UI元素:', { \n            fileInput: !!fileInput, \n            uploadBtn: !!uploadBtn, \n            translateBtn: !!translateBtn, \n            exportBtn: !!exportBtn \n        });\n\n        // 处理文件选择按钮点击\n        if (uploadBtn) {\n            console.log('为uploadBtn添加点击事件监听器');\n            uploadBtn.addEventListener('click', () => {\n                console.log('uploadBtn被点击');\n                fileInput?.click();\n            });\n        }\n\n        if (fileInput) {\n            console.log('为fileInput添加change事件监听器');\n            fileInput.addEventListener('change', (e) => {\n                console.log('fileInput change事件触发');\n                this.handleFileSelect(e);\n                if (actionButtons) {\n                    actionButtons.style.display = 'block';\n                }\n            });\n        }\n        \n        if (translateBtn) {\n            console.log('为translateBtn添加点击事件监听器');\n            translateBtn.addEventListener('click', () => {\n                console.log('translateBtn被点击');\n                this.handleTranslateClick();\n            });\n        }\n        \n        if (exportBtn) {\n            console.log('为exportBtn添加点击事件监听器');\n            exportBtn.addEventListener('click', () => {\n                console.log('exportBtn被点击');\n                this.exportToExcel();\n            });\n        }\n        \n        // 标记事件监听器已初始化\n        ExcelTranslator._eventsInitialized = true;\n        console.log('事件监听器初始化完成');\n    }\n\n    /**\n     * 处理文件选择事件\n     * @param {Event} event - 文件选择事件\n     */\n    async handleFileSelect(event) {\n        const file = event.target.files[0];\n        if (!file) return;\n\n        try {\n            this.currentFileName = file.name;\n            this.logger.log(`正在读取文件: ${file.name}`, 'info');\n            this.progressBar.show();\n            \n            // 读取Excel文件\n            this.data = await readExcelFile(file);\n            \n            // 更新工作表选择器\n            this.updateSheetSelector(Object.keys(this.data));\n            \n            // 显示第一个工作表\n            if (Object.keys(this.data).length > 0) {\n                this.currentSheet = Object.keys(this.data)[0];\n                this.displaySheet();\n                this.logger.log(`已加载工作表: ${this.currentSheet}`, 'success');\n            }\n            \n            // 尝试自动检测源语言列\n            this.autoDetectSourceLanguage();\n            \n        } catch (error) {\n            this.logger.log(`读取文件失败: ${error.message}`, 'error');\n            console.error('文件读取错误:', error);\n        } finally {\n            this.progressBar.hide();\n        }\n    }\n\n    /**\n     * 自动检测源语言列\n     */\n    autoDetectSourceLanguage() {\n        if (!this.currentSheet || !this.data[this.currentSheet] || !this.sourceLangSelect) return;\n        \n        const { headerRows } = this.data[this.currentSheet];\n        if (headerRows.length < 2) return;\n        \n        // 获取表头行\n        const headerRow = headerRows[1];\n        \n        // 遍历所有列标题，尝试匹配语言\n        for (let i = 0; i < headerRow.length; i++) {\n            const columnHeader = headerRow[i];\n            const language = LanguageUtils.findLanguageByColumnHeader(columnHeader);\n            \n            if (language === 'Chinese') {\n                // 如果找到中文列，设置为源语言\n                this.sourceLangSelect.value = 'Chinese';\n                this.logger.log(`已自动检测到源语言列: ${columnHeader} (列 ${this.getExcelColumnName(i)})`, 'info');\n                break;\n            }\n        }\n    }\n\n    /**\n     * 更新工作表选择器\n     * @param {Array} sheets - 工作表名称数组\n     */\n    updateSheetSelector(sheets) {\n        const sheetSelector = document.getElementById('sheetSelector');\n        if (!sheetSelector) return;\n\n        // 清除现有选项\n        sheetSelector.innerHTML = '';\n\n        // 添加新选项\n        sheets.forEach(sheetName => {\n            const option = document.createElement('option');\n            option.value = sheetName;\n            option.textContent = sheetName;\n            sheetSelector.appendChild(option);\n        });\n        \n        // 添加工作表切换事件\n        sheetSelector.addEventListener('change', () => {\n            this.currentSheet = sheetSelector.value;\n            this.displaySheet();\n            this.logger.log(`已切换到工作表: ${this.currentSheet}`, 'info');\n        });\n    }\n\n    /**\n     * 显示当前工作表\n     */\n    displaySheet() {\n        if (!this.tableOutput || !this.currentSheet || !this.data[this.currentSheet]) {\n            console.error('无法显示表格：', {\n                tableOutput: !!this.tableOutput,\n                currentSheet: this.currentSheet,\n                hasData: this.data[this.currentSheet] ? true : false\n            });\n            return;\n        }\n\n        const sheetData = this.data[this.currentSheet];\n        \n        // 使用TableRenderer渲染表格\n        this.tableRenderer.renderTable(sheetData, (rowIndex, colIndex, content) => {\n            // 单元格编辑回调\n            if (rowIndex < sheetData.headerRows.length) {\n                sheetData.headerRows[rowIndex][colIndex] = content;\n            } else {\n                const dataRowIndex = rowIndex - sheetData.headerRows.length;\n                // 确保数据行数组有足够的长度\n                while (sheetData.rows.length <= dataRowIndex) {\n                    sheetData.rows.push([]);\n                }\n                // 确保数据行有足够的列\n                while (sheetData.rows[dataRowIndex].length <= colIndex) {\n                    sheetData.rows[dataRowIndex].push('');\n                }\n                sheetData.rows[dataRowIndex][colIndex] = content;\n            }\n        });\n    }\n\n    /**\n     * 处理翻译按钮点击事件\n     */\n    async handleTranslateClick() {\n        if (!this.currentSheet || !this.data[this.currentSheet]) {\n            this.logger.log('没有可翻译的数据', 'warning');\n            return;\n        }\n\n        const translateBtn = document.getElementById('translateBtn');\n        const stopBtn = document.getElementById('stopTranslateBtn');\n        \n        // 显示停止按钮，隐藏翻译按钮\n        if (translateBtn) translateBtn.style.display = 'none';\n        if (stopBtn) {\n            stopBtn.style.display = 'inline-block';\n            stopBtn.disabled = false;\n        }\n        \n        // 重置停止标志\n        this.shouldStopTranslation = false;\n        \n        // 显示进度条\n        this.progressBar.show();\n        this.progressBar.updateProgress({ current: 0, total: 100 });\n        \n        // 获取API密钥，优先使用环境变量中的ALI_API_KEY\n        if (process.env.ALI_API_KEY) {\n            this.apiKey = process.env.ALI_API_KEY;\n            console.log('使用环境变量中的API密钥');\n        } else {\n            this.apiKey = document.getElementById('apiKey')?.value || '';\n        }\n        \n        if (!this.apiKey) {\n            this.logger.log('请输入API密钥', 'error');\n            translateBtn.style.display = 'inline-block';\n            stopBtn.style.display = 'none';\n            this.progressBar.hide();\n            return;\n        }\n        \n        // 获取源语言\n        const sourceLang = this.sourceLangSelect?.value || 'Chinese';\n        const sourceApiCode = LanguageUtils.getApiLanguageCode(sourceLang);\n        \n        // 查找源语言列\n        const { headerRows, rows } = this.data[this.currentSheet];\n        if (headerRows.length < 2) {\n            this.logger.log('错误：表格缺少表头行', 'error');\n            translateBtn.style.display = 'inline-block';\n            stopBtn.style.display = 'none';\n            this.progressBar.hide();\n            return;\n        }\n        \n        const headerRow = headerRows[1];\n        let sourceColumnIndex = -1;\n        \n        // 查找源语言列\n        for (let i = 0; i < headerRow.length; i++) {\n            const columnHeader = headerRow[i];\n            const language = LanguageUtils.findLanguageByColumnHeader(columnHeader);\n            const sourceLanguageConfig = LanguageUtils.getSourceLanguageConfig();\n            \n            if (language === sourceLanguageConfig[LanguageUtils.getLanguageDisplayName(sourceLang)]) {\n                sourceColumnIndex = i;\n                break;\n            }\n        }\n        \n        if (sourceColumnIndex === -1) {\n            this.logger.log(`错误：找不到源语言(${LanguageUtils.getLanguageDisplayName(sourceLang)})列`, 'error');\n            translateBtn.style.display = 'inline-block';\n            stopBtn.style.display = 'none';\n            this.progressBar.hide();\n            return;\n        }\n        \n        // 查找所有目标语言列\n        const targetColumns = [];\n        const sourceLanguageConfig = LanguageUtils.getSourceLanguageConfig();\n        \n        for (let i = 0; i < headerRow.length; i++) {\n            if (i === sourceColumnIndex) continue;\n            \n            const columnHeader = headerRow[i];\n            const language = LanguageUtils.findLanguageByColumnHeader(columnHeader);\n            \n            if (language && language !== sourceLanguageConfig[LanguageUtils.getLanguageDisplayName(sourceLang)]) {\n                targetColumns.push({\n                    index: i,\n                    langCode: language,\n                    display: columnHeader\n                });\n            }\n        }\n        \n        if (targetColumns.length === 0) {\n            this.logger.log('错误：找不到任何目标语言列', 'error');\n            translateBtn.style.display = 'inline-block';\n            stopBtn.style.display = 'none';\n            this.progressBar.hide();\n            return;\n        }\n        \n        this.logger.log(`开始翻译，源语言: ${LanguageUtils.getLanguageDisplayName(sourceLang)} (列 ${this.getExcelColumnName(sourceColumnIndex)})`, 'info');\n        this.logger.log('目标语言: ' + targetColumns.map(c => `${c.display} (列 ${this.getExcelColumnName(c.index)})`).join(', '), 'info');\n        \n        try {\n            // 创建翻译管理器\n            const translationManager = new TranslationManager(\n                this.apiKey, \n                this.logger.log.bind(this.logger),\n                this.progressBar\n            );\n            \n            // 设置停止按钮事件\n            if (stopBtn) {\n                // 移除可能存在的旧事件监听器\n                const newStopBtn = stopBtn.cloneNode(true);\n                stopBtn.parentNode.replaceChild(newStopBtn, stopBtn);\n                \n                newStopBtn.onclick = () => {\n                    this.shouldStopTranslation = true;\n                    translationManager.stopTranslation();\n                    newStopBtn.disabled = true;\n                    this.logger.log('正在停止翻译...', 'warning');\n                };\n            }\n            \n            // 执行翻译\n            await translationManager.executeTranslation(\n                rows,\n                sourceColumnIndex,\n                sourceLang,\n                targetColumns,\n                (rowIndex, colIndex, text) => {\n                    // 更新单元格回调\n                    this.tableRenderer.updateCellInDOM(rowIndex, colIndex, text, headerRows.length);\n                }\n            );\n            \n        } catch (error) {\n            console.error('翻译过程出错:', error);\n            this.logger.log(`翻译过程出错: ${error.message || String(error)}`, 'error');\n        } finally {\n            translateBtn.style.display = 'inline-block';\n            stopBtn.style.display = 'none';\n            stopBtn.disabled = true;\n            this.progressBar.hide();\n        }\n    }\n\n    /**\n     * 导出到Excel\n     */\n    async exportToExcel() {\n        if (!this.currentSheet || !this.data[this.currentSheet]) {\n            this.logger.log('没有可导出的数据', 'warning');\n            return;\n        }\n\n        try {\n            const workbook = createExcelWorkbook(this.data);\n            XLSX.writeFile(workbook, `${this.currentFileName.replace('.xlsx', '')}_translated.xlsx`);\n            this.logger.log('导出成功', 'success');\n        } catch (error) {\n            if (error instanceof Error) {\n                this.logger.log(`导出失败: ${error.message}`, 'error');\n            } else {\n                this.logger.log('导出失败: 未知错误', 'error');\n            }\n        }\n    }\n\n    /**\n     * 获取Excel列名\n     * @param {number} index - 列索引\n     * @returns {string} - 列名\n     */\n    getExcelColumnName(index) {\n        return this.tableRenderer.getExcelColumnName(index);\n    }\n}\n","import * as XLSX from 'xlsx';\n\n/**\n * 读取Excel文件并解析内容\n * @param {File} file - Excel文件\n * @returns {Promise<Object>} - 解析后的数据，按工作表名称组织\n */\nexport function readExcelFile(file) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        \n        reader.onload = (e) => {\n            try {\n                const data = e.target?.result;\n                const workbook = XLSX.read(data, { type: 'binary' });\n                const result = {};\n\n                workbook.SheetNames.forEach(sheetName => {\n                    const worksheet = workbook.Sheets[sheetName];\n                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });\n                    \n                    // 分离表头行和数据行\n                    const headerRows = jsonData.slice(0, 2);\n                    const rows = jsonData.slice(2);\n\n                    result[sheetName] = {\n                        headerRows,\n                        rows\n                    };\n                });\n\n                resolve(result);\n            } catch (error) {\n                reject(error);\n            }\n        };\n\n        reader.onerror = () => {\n            reject(new Error('文件读取失败'));\n        };\n\n        reader.readAsBinaryString(file);\n    });\n}\n\n/**\n * 创建Excel工作簿\n * @param {Object} data - 数据对象，按工作表名称组织\n * @returns {XLSX.WorkBook} - 创建的工作簿\n */\nexport function createExcelWorkbook(data) {\n    const workbook = XLSX.utils.book_new();\n\n    Object.entries(data).forEach(([sheetName, sheetData]) => {\n        const allRows = [...sheetData.headerRows, ...sheetData.rows];\n        const worksheet = XLSX.utils.aoa_to_sheet(allRows);\n        XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);\n    });\n\n    return workbook;\n}\n\n/**\n * 获取Excel列名\n * @param {number} index - 列索引\n * @returns {string} - 列名（如A, B, AA等）\n */\nexport function getExcelColumnName(index) {\n    let columnName = '';\n    while (index >= 0) {\n        columnName = String.fromCharCode(65 + (index % 26)) + columnName;\n        index = Math.floor(index / 26) - 1;\n    }\n    return columnName;\n}\n","import './styles.css';\nimport { ExcelTranslator } from './ExcelTranslator.js';\n\nconsole.log('index.js 被加载');\n\n// 初始化应用\nwindow.addEventListener('DOMContentLoaded', () => {\n    console.log('DOMContentLoaded 事件触发');\n    \n    // 检查是否已经有实例\n    if (window.excelTranslatorInstance) {\n        console.log('已存在 ExcelTranslator 实例，不再创建新实例');\n        return;\n    }\n    \n    console.log('创建新的 ExcelTranslator 实例');\n    window.excelTranslatorInstance = new ExcelTranslator();\n    console.log('ExcelTranslator 实例创建完成');\n});\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","__webpack_require__.j = 792;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t792: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkexcel_to_structured_data\"] = self[\"webpackChunkexcel_to_structured_data\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","__webpack_require__.nc = undefined;","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [121], () => (__webpack_require__(6437)))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","ProgressBar","constructor","this","progressContainer","document","querySelector","progressFill","progressText","progressDetails","progressBatchCounter","createElement","className","style","textAlign","marginTop","fontSize","color","parentNode","insertBefore","nextSibling","updateProgress","data","percentage","current","total","width","textContent","Math","round","text","updateBatchProgress","progress","overallPercentage","completedBatches","totalBatches","currentBatchId","batchProgress","completedTasksInCurrentBatch","totalTasksInCurrentBatch","reset","show","display","hide","Logger","container","log","message","type","logEntry","Date","toLocaleTimeString","appendChild","scrollTop","scrollHeight","TableRenderer","getExcelColumnName","index","columnName","String","fromCharCode","floor","updateCellInDOM","rowIndex","colIndex","headerRowsCount","tableWrapper","table","rows","querySelectorAll","targetRow","i","length","row","rowNumberCell","toString","children","cell","renderTable","sheetData","onCellEdit","innerHTML","headerRows","allRows","maxColumns","max","map","colNumberRow","emptyTh","th","forEach","tr","td","contentEditable","addEventListener","addTableStyles","styleId","getElementById","id","head","instance","console","embeddingService","ollamaUrl","modelName","qdrantUrl","collectionName","vectorSize","qdrantClient","url","checkCompatibility","timeout","retries","initializeCollection","delay","getCollections","collections","some","c","name","collectionInfo","getCollection","config","params","vectors","size","warn","infoError","error","createCollection","distance","includes","Promise","resolve","setTimeout","generateEmbedding","trim","Error","requestBody","model","prompt","JSON","stringify","response","method","headers","body","ok","errorText","status","responseText","parse","embedding","Array","isArray","storeEmbedding","metadata","success","uuid","randomUUID","upsert","wait","points","vector","payload","storeEntryVectors","entry","collectionError","Chinese","English","Japanese","Korean","Spanish","French","German","Russian","Thai","Italian","Indonesian","Portuguese","vector_cn","vector_en","cnError","enError","point","upsertError","retryError","updateEntryVectors","testService","checkQdrantConnection","testText","collectionExists","embeddingDimension","join","searchSimilar","language","limit","searchResults","substring","embeddingError","isEnglish","toLowerCase","vectorName","search","with_payload","qdrantError","initError","processedResults","result","similarity","score","chinese","english","sort","a","b","calculateCosineSimilarity","vec1","vec2","dotProduct","norm1","norm2","sqrt","deleteEmbedding","delete","addToVectorStore","deleteVector","LanguageUtils","getSourceLanguages","getSourceLanguageConfig","getLanguageMappings","columnHeader","targetLang","getLanguageDisplayName","langCode","getApiLanguageCode","findLanguageByColumnHeader","mappings","mapping","TranslationService","apiKey","logCallback","apiEndpoint","shouldStopTranslation","stopTranslation","resetStopFlag","getTranslationMemory","sourceLanguage","targetLanguage","standardSourceLang","standardTargetLang","vectorLanguage","similarEntries","sourceField","targetField","tmList","sourceFieldLower","targetFieldLower","source","target","push","Object","keys","possibleTargetField","find","key","possibleTarget","vectorError","translateBatch","batch","tasks","rowIndices","task","minRow","min","maxRow","rowRange","sourceLang","to","batchId","validTasks","filter","undefined","translateSingle","messages","role","content","t","translation_options","source_lang","target_lang","temperature","max_tokens","choices","translatedContent","translatedLines","split","minLength","translatedLine","translation","missingCount","textType","from","TranslationManager","progressBar","createBatches","items","batchSize","batches","slice","prepareTranslationTasks","sourceColumnIndex","targetColumns","translationTasks","sourceText","targetColumn","targetColumnIndex","targetText","organizeTasksIntoBatches","tasksByLanguage","lang","langTasks","langBatches","completed","executeTranslation","updateCellCallback","translationService","tasksWithResults","tasksWithoutResults","ExcelTranslator","static","tableOutput","logOutput","logger","tableRenderer","currentSheet","currentFileName","sourceLangSelect","initializeUI","initializeEventListeners","stopBtn","newStopBtn","cloneNode","replaceChild","disabled","stack","_eventsInitialized","fileInput","uploadBtn","translateBtn","exportBtn","actionButtons","click","e","handleFileSelect","handleTranslateClick","exportToExcel","event","file","files","reject","reader","FileReader","onload","workbook","SheetNames","sheetName","worksheet","Sheets","jsonData","sheet_to_json","header","onerror","readAsBinaryString","readExcelFile","updateSheetSelector","displaySheet","autoDetectSourceLanguage","headerRow","value","sheets","sheetSelector","option","hasData","dataRowIndex","sourceLanguageConfig","translationManager","bind","onclick","book_new","entries","aoa_to_sheet","book_append_sheet","createExcelWorkbook","replace","window","excelTranslatorInstance","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","loaded","__webpack_modules__","call","m","O","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","j","every","splice","r","n","getter","__esModule","d","definition","o","defineProperty","enumerable","get","g","globalThis","Function","obj","prop","prototype","hasOwnProperty","nmd","paths","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","chunkLoadingGlobal","self","nc","__webpack_exports__"],"sourceRoot":""}